{"messages": [{"role": "user", "content": "Generate an LED fade effect from full brightness to off"}, {"role": "assistant", "content": "```javascript\nconst brightness = 255 * Math.exp(-time / tau);\n```\n\nThis uses exponential decay where:\n- Formula type: Decay (things diminishing)\n- Structure: exp(-t/τ) with NEGATIVE exponent\n- Never use (1-exp(t/τ)) for fade - that's growth\n- tau controls fade speed (0.3s = fast, 0.1s = standard, 0.03s = smooth)"}]}
{"messages": [{"role": "user", "content": "Create LED brightness that starts at 0 and reaches full brightness"}, {"role": "assistant", "content": "```javascript\nconst brightness = 255 * (1 - Math.exp(-time / tau));\n```\n\nThis uses exponential growth (complement of decay) where:\n- Formula type: Growth (things approaching max)\n- Structure: (1-exp(-t/τ)) - complement form\n- Never use exp(-t/τ) alone for growth - that's decay\n- The (1-...) inverts decay to create approach behavior"}]}
{"messages": [{"role": "user", "content": "Write servo positioning code that smoothly approaches target angle over 200ms"}, {"role": "assistant", "content": "```cpp\nfloat tau = 0.2; // 200ms time constant\nfloat angle = targetAngle * (1 - exp(-elapsedTime / tau));\n```\n\nThis uses step response formula where:\n- Formula type: Step response (position tracking)\n- Structure: target * (1-exp(-t/τ))\n- tau = 0.2 matches the 200ms specification\n- Reaches 95% of target in ~3*tau = 600ms"}]}
{"messages": [{"role": "user", "content": "Implement a PID controller with integral term for motor speed"}, {"role": "assistant", "content": "```cpp\nfloat error = targetSpeed - currentSpeed;\nintegralSum += error * dt; // MUST multiply by dt\nfloat integral = ki * integralSum;\nfloat output = kp * error + integral + kd * (error - lastError) / dt;\n```\n\nCritical: The integral term MUST scale with dt for frame-rate independence. Without dt scaling, the controller behavior changes with different loop rates."}]}
{"messages": [{"role": "user", "content": "What's the difference between decay and growth formulas?"}, {"role": "assistant", "content": "Decay vs Growth in Forge Theory:\n\n**Decay (diminishing):** exp(-t/τ)\n- Use for: fade, discharge, cool, dim\n- Starts at max, approaches zero\n- Example: LED fade, battery discharge\n\n**Growth (approaching):** (1-exp(-t/τ))\n- Use for: charge, heat, rise, brighten\n- Starts at zero, approaches max\n- Example: LED rise, capacitor charge\n\n**Key insight:** Growth is the complement of decay. Mathematically: growth = 1 - decay"}]}
{"messages": [{"role": "user", "content": "How do I choose tau for different motion speeds?"}, {"role": "assistant", "content": "Tau (τ) selection guidelines:\n\n**Fast/Snappy (τ=0.3s):**\n- Weapon strikes\n- Emergency stops\n- Quick reactions\n\n**Standard (τ=0.1s):**\n- Normal servo positioning\n- LED transitions\n- General robot motion\n\n**Smooth/Gentle (τ=0.03s):**\n- Camera gimbals\n- Precision positioning\n- Aesthetic animations\n\n**Rule of thumb:** System settles in ~5*τ (99% of final value)"}]}
{"messages": [{"role": "user", "content": "Create a breathing LED effect that fades in and out continuously"}, {"role": "assistant", "content": "```cpp\nfloat breathingLED(float time, float period) {\n  float phase = fmod(time, period);\n  float halfPeriod = period / 2.0;\n  \n  if (phase < halfPeriod) {\n    // Growth phase: 0 → 255\n    float t = phase;\n    return 255 * (1 - exp(-t / 0.1));\n  } else {\n    // Decay phase: 255 → 0\n    float t = phase - halfPeriod;\n    return 255 * exp(-t / 0.1);\n  }\n}\n```\n\nThis uses both formulas:\n- First half: growth (1-exp(-t/τ))\n- Second half: decay exp(-t/τ)\n- Creates smooth inhale/exhale effect"}]}
{"messages": [{"role": "user", "content": "Why can't I use exp(t/tau) with a positive exponent?"}, {"role": "assistant", "content": "Positive exponents cause exponential EXPLOSION, not decay:\n\n```cpp\n// WRONG - explodes to infinity:\nbrightness = 255 * exp(t / tau);\n// At t=1s: exp(1/0.1) = exp(10) = 22,026 (way over 255!)\n\n// CORRECT - decays to zero:\nbrightness = 255 * exp(-t / tau);\n// At t=1s: exp(-1/0.1) = exp(-10) = 0.000045\n```\n\nPhysical systems (fading, cooling, discharge) follow decay, which requires NEGATIVE exponents. Positive exponents model runaway processes like nuclear reactions."}]}
{"messages": [{"role": "user", "content": "How does the exponential formula relate to RC circuits?"}, {"role": "assistant", "content": "RC circuits are the physical embodiment of exponential decay:\n\n**Charging (growth):**\n```cpp\nV(t) = V_max * (1 - exp(-t / (R*C)))\n```\n\n**Discharging (decay):**\n```cpp\nV(t) = V_initial * exp(-t / (R*C))\n```\n\nWhere tau = R*C is the time constant.\n\n**Example:** 100Ω resistor + 10µF capacitor:\n- tau = 100 * 0.00001 = 0.001s = 1ms\n- 5*tau = 5ms for full charge/discharge"}]}
{"messages": [{"role": "user", "content": "What's the settling time for exponential systems?"}, {"role": "assistant", "content": "Exponential settling times:\n\n**1*tau:** 63.2% of final value\n**2*tau:** 86.5% of final value\n**3*tau:** 95.0% of final value (engineering standard)\n**4*tau:** 98.2% of final value\n**5*tau:** 99.3% of final value (near-perfect)\n\n**Example:** Servo with tau=0.2s\n- 0.6s reaches 95% of target (3*tau)\n- 1.0s reaches 99.3% of target (5*tau)\n\nUse 3*tau for motion planning, 5*tau for precision."}]}
{"messages": [{"role": "user", "content": "Should I use utility functions for exponential formulas?"}, {"role": "assistant", "content": "**NO - keep Forge Theory formulas inline:**\n\n```cpp\n// BAD - hides the math:\nfloat value = exponentialDecay(time, tau);\n\n// GOOD - validator can check it:\nfloat value = 255 * exp(-time / tau);\n```\n\n**Why?**\n1. Validator needs to see the actual formula structure\n2. Auto-fix can't correct hidden implementations\n3. Code reviewers can verify Forge Theory compliance\n4. Training data captures the actual mathematical pattern\n\nUtility functions are fine for non-Forge Theory code."}]}
{"messages": [{"role": "user", "content": "How do I implement non-blocking delays using exponential timing?"}, {"role": "assistant", "content": "```cpp\nunsigned long lastUpdate = 0;\nconst float tau = 0.1; // 100ms time constant\n\nvoid loop() {\n  unsigned long now = millis();\n  float dt = (now - lastUpdate) / 1000.0; // Convert to seconds\n  \n  if (dt > 0.016) { // ~60 FPS\n    float brightness = 255 * exp(-dt / tau);\n    ledcWrite(LED_CHANNEL, brightness);\n    lastUpdate = now;\n  }\n}\n```\n\nThis uses millis() for non-blocking timing with exponential decay. Never use delay() - it blocks the entire program."}]}
{"messages": [{"role": "user", "content": "What triggers decay vs growth formula selection?"}, {"role": "assistant", "content": "**Decay triggers (use exp(-t/τ)):**\n- Keywords: fade, decay, discharge, cool, dim, fall, drop\n- Context: brightness decreasing, temperature cooling, charge depleting\n- Direction: max → zero\n\n**Growth triggers (use (1-exp(-t/τ))):**\n- Keywords: charge, heat, rise, grow, brighten, approach, ramp\n- Context: brightness increasing, temperature heating, charge accumulating\n- Direction: zero → max\n\n**Step response triggers (use target*(1-exp(-t/τ))):**\n- Keywords: servo, motor, position, weapon, tracking\n- Context: approaching a target value (not max)\n- Direction: current → target"}]}
{"messages": [{"role": "user", "content": "Why is (1-exp(-t/tau)) called the complement form?"}, {"role": "assistant", "content": "The complement form inverts decay to create growth:\n\n**Decay:** y = exp(-t/τ)\n- At t=0: y=1.0 (100%)\n- At t=∞: y=0.0 (0%)\n- Goes from full to empty\n\n**Growth (complement):** y = 1 - exp(-t/τ)\n- At t=0: y=0.0 (0%)\n- At t=∞: y=1.0 (100%)\n- Goes from empty to full\n\n**Mathematically:** growth(t) = 1 - decay(t)\n\nThis is why it's the 'complement' - it's the inverse behavior of the same exponential curve."}]}
{"messages": [{"role": "user", "content": "How does PID dt scaling work mathematically?"}, {"role": "assistant", "content": "**Without dt scaling (WRONG):**\n```cpp\nintegral += error; // Units: error-samples\noutput = kp*error + ki*integral;\n// Problem: integral accumulation depends on loop frequency!\n```\n\n**With dt scaling (CORRECT):**\n```cpp\nintegral += error * dt; // Units: error-seconds\noutput = kp*error + ki*integral;\n// Now: integral represents area under error curve, independent of sample rate\n```\n\n**Example:**\n- 10Hz loop: dt=0.1s, error=5 → adds 0.5 per iteration\n- 100Hz loop: dt=0.01s, error=5 → adds 0.05 per iteration\n- Same total integral accumulation over time!"}]}
{"messages": [{"role": "user", "content": "What's the relationship between tau and cutoff frequency?"}, {"role": "assistant", "content": "For first-order systems, tau and cutoff frequency are inversely related:\n\n**Formula:** fc = 1 / (2π * τ)\n\n**Examples:**\n- tau = 0.1s → fc = 1.59 Hz\n- tau = 0.01s → fc = 15.9 Hz\n- tau = 0.001s → fc = 159 Hz\n\n**Inverse:** τ = 1 / (2π * fc)\n\n**For RC filters:**\nfc = 1 / (2π * R * C)\n\nThis connects time-domain (tau) to frequency-domain (cutoff) analysis."}]}
{"messages": [{"role": "user", "content": "How do I smooth LDR sensor readings using exponential filtering?"}, {"role": "assistant", "content": "```cpp\nfloat filteredValue = 0;\nconst float tau = 0.01; // 10ms time constant\nfloat lastTime = 0;\n\nvoid loop() {\n  float now = millis() / 1000.0;\n  float dt = now - lastTime;\n  \n  int rawValue = analogRead(LDR_PIN);\n  \n  // Exponential moving average:\n  float alpha = dt / tau;\n  filteredValue = filteredValue * (1 - alpha) + rawValue * alpha;\n  \n  lastTime = now;\n}\n```\n\n**This is exponential decay applied to noise:**\n- alpha = dt/tau (weighting factor)\n- Smooth response with tau time constant\n- No abrupt jumps from noise spikes"}]}
{"messages": [{"role": "user", "content": "What's wrong with using linear ramps instead of exponential curves?"}, {"role": "assistant", "content": "**Linear ramps (AVOID):**\n```cpp\nbrightness += 5; // Constant increment\nif (brightness > 255) brightness = 255;\n```\n**Problems:**\n- Abrupt start (infinite acceleration)\n- Abrupt stop (infinite deceleration)\n- Frame-rate dependent\n- Doesn't model physical systems\n\n**Exponential curves (PREFERRED):**\n```cpp\nbrightness = 255 * (1 - exp(-t / tau));\n```\n**Advantages:**\n- Smooth start (zero initial velocity)\n- Smooth approach (asymptotic)\n- Time-based (frame-rate independent)\n- Matches physics (RC, thermal, mechanical)\n\nExponentials feel natural because they mirror real-world dynamics."}]}
{"messages": [{"role": "user", "content": "How do I convert between tau and rise time?"}, {"role": "assistant", "content": "**Rise time (10% → 90%):** t_rise ≈ 2.2 * τ\n\n**From specification to tau:**\n```cpp\n// Spec: \"Reach target in 200ms\"\n// For 90% settling: tau = t_rise / 2.2\nfloat tau = 0.2 / 2.2; // = 0.091s\n\n// For 95% settling (3*tau):\nfloat tau = 0.2 / 3; // = 0.067s\n\n// For 99% settling (5*tau):\nfloat tau = 0.2 / 5; // = 0.04s\n```\n\n**Choose based on precision requirements:**\n- Quick motion: use 3*tau = spec\n- Precision: use 5*tau = spec"}]}
{"messages": [{"role": "user", "content": "Can I chain multiple exponential stages together?"}, {"role": "assistant", "content": "Yes! Multi-stage exponential systems:\n\n```cpp\nfloat weaponSequence(float t) {\n  if (t < 0.2) {\n    // Stage 1: Charge (0-200ms)\n    return targetAngle * (1 - exp(-t / 0.05));\n  } else if (t < 0.3) {\n    // Stage 2: Hold (200-300ms)\n    return targetAngle;\n  } else if (t < 0.5) {\n    // Stage 3: Return (300-500ms)\n    float t_decay = t - 0.3;\n    return targetAngle * exp(-t_decay / 0.05);\n  } else {\n    return 0; // Stage 4: Rest\n  }\n}\n```\n\nEach stage uses appropriate formula type (growth/hold/decay)."}]}
